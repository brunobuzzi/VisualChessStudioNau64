| package |
package := Package name: 'ChessPiecesMovementsEngine'.
package paxVersion: 1;
	basicComment: ''.


package classNames
	add: #ChessEastOrientation;
	add: #ChessEngineOrientationTreeNode;
	add: #ChessEngineSquareTreeNode;
	add: #ChessEngineTreeNode;
	add: #ChessNorthOrientation;
	add: #ChessOrientation;
	add: #ChessOrientationVector;
	add: #ChessSouthOrientation;
	add: #ChessVector;
	add: #ChessWestOrientation;
	add: #SquaresDictionary;
	yourself.

package methodNames
	add: #Bishop -> #orientations;
	add: #ChessPiece -> #checkForAbsolutePinFrom:to:;
	add: #ChessPiece -> #currentChessSquare;
	add: #ChessPiece -> #isInvalidMoveFrom:to:;
	add: #ChessPiece -> #isValidMoveFrom:to:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:on:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:on:on:;
	add: #ChessPiece -> #orientations;
	add: #ChessPiece -> #orientationVectorFrom:to:;
	add: #King -> #isValidBlackCastleMoveFrom:to:on:on:;
	add: #King -> #isValidCastleMoveFrom:to:on:on:;
	add: #King -> #isValidMoveFromCoordinate:to:on:on:;
	add: #King -> #isValidWhiteCastleMoveFrom:to:on:on:;
	add: #King -> #orientations;
	add: #King -> #squaresScopeFrom:;
	add: #Knight -> #orientations;
	add: #Knight -> #squaresScopeFrom:;
	add: #Pawn -> #isValidBlackEnPassantMoveFrom:to:on:;
	add: #Pawn -> #isValidEnPassantMoveFrom:to:on:;
	add: #Pawn -> #isValidMoveFromCoordinate:to:on:;
	add: #Pawn -> #isValidWhiteEnPassantMoveFrom:to:on:;
	add: #Pawn -> #orientations;
	add: #Pawn -> #squaresScopeFrom:;
	add: #Queen -> #orientations;
	add: #Rook -> #orientations;
	add: #SlidingPiece -> #squaresScopeFrom:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'ChessBasicElements'
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base'
	'..\Core\Object Arts\Dolphin\MVP\Icons\Dolphin Text Tile Icons').

package!

"Class Definitions"!

Object subclass: #ChessEngineTreeNode
	instanceVariableNames: 'tree parentNode children'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessVector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #SquaresDictionary
	instanceVariableNames: 'squares piece'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessEngineTreeNode subclass: #ChessEngineOrientationTreeNode
	instanceVariableNames: 'orientation'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessEngineTreeNode subclass: #ChessEngineSquareTreeNode
	instanceVariableNames: 'square movementEngine'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessEastOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessNorthOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessSouthOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessWestOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessVector subclass: #ChessOrientationVector
	instanceVariableNames: 'southOrNorth eastOrWest'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!Bishop methodsFor!

orientations

	^OrderedCollection 
		with: ChessOrientationVector newNorthWest 
		with: ChessOrientationVector newNorthEast
		with: ChessOrientationVector newSouthWest
		with: ChessOrientationVector newSouthEast! !
!Bishop categoriesForMethods!
orientations!new framework!orientations do!public! !
!

!ChessPiece methodsFor!

checkForAbsolutePinFrom: originChessSquare to: targetChessSquare
	| pins orientation |
	pins := OrderedCollection new.
	self oppositeSideDo: [:oppositeSide | 
		oppositeSide piecesDo: [:piece | | pinnedPieces |
			pinnedPieces := piece pinnedPieces.
			pins addAll: (pinnedPieces select: [:pin | (pin pinnedPieceIs: self) and: [pin isAbsolute]]).
		]
	].
	pins isEmpty ifTrue: [^true].

	orientation := ChessOrientationVector newFrom:  originChessSquare to: targetChessSquare.

	^pins allSatisfy: [:pin | orientation isPinCompatibleWithOrientationNamed: pin orientation]!

currentChessSquare

	^chessSide currentChessSquareFor: self!

isInvalidMoveFrom: originChessSquare to: targetChessSquare

	self validSquaresFrom: originChessSquare do: [:scopeSquare | scopeSquare == targetChessSquare ifTrue: [^false]].

	^true

	!

isValidMoveFrom: originChessSquare to: targetChessSquare
	| isValid |

	isValid := false.
	self validSquaresFrom: originChessSquare do: [:scopeSquare | scopeSquare == targetChessSquare ifTrue: [isValid := true]].

	isValid ifTrue: [^self checkForAbsolutePinFrom: originChessSquare to: targetChessSquare].

	^isValid

	!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate

	^self isValidMoveFrom: (originCoordinate asChessSquareIn: self systemRoot) to: (targetCoordinate asChessSquareIn: self systemRoot)!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGame

	^self isValidMoveFrom: (originCoordinate asChessSquareIn: self systemRoot) to: (targetCoordinate asChessSquareIn: self systemRoot)!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessbord on: aChessGame

	^self isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGame!

orientations

	^OrderedCollection new!

orientationVectorFrom: sourceChessSquare to: targetChessSquare

	^ChessOrientationVector newFrom: sourceChessSquare to: targetChessSquare.! !
!ChessPiece categoriesForMethods!
checkForAbsolutePinFrom:to:!new framework!public! !
currentChessSquare!public! !
isInvalidMoveFrom:to:!new framework!public! !
isValidMoveFrom:to:!new framework!public! !
isValidMoveFromCoordinate:to:!public! !
isValidMoveFromCoordinate:to:on:!public! !
isValidMoveFromCoordinate:to:on:on:!public! !
orientations!new framework!public! !
orientationVectorFrom:to:!public! !
!

!King methodsFor!

isValidBlackCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame

	((originCoordinate ~= #e8) or: [(targetCoordinate ~= #g8) and:[targetCoordinate ~= #c8]]) ifTrue: [^false].

	(targetCoordinate = #g8) ifTrue: [aChessGame ifBlackKindSideCastleNotEnabled: [^false]].

	(targetCoordinate = #c8) ifTrue: [aChessGame ifBlackQueenSideCastleNotEnabled: [^false]].

	aChessboard oppositeSideOfSideNamed: (aChessGame nextSideToMoveOn: aChessboard) do: [:side | 
		side allAttackedSquaresDo: [:square |  | castleSquareCollection |
			castleSquareCollection := (targetCoordinate = #g1)
				ifTrue: [#(#e8 #f8 #g8)]
				ifFalse: [#(#e8#d8 #c8 #b8)].
			(castleSquareCollection includes: square coordinate) ifTrue: [^false].
		].
	].
	^true
	!

isValidCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame

	^self isBlack 
	ifTrue: [self isValidBlackCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame] 
	ifFalse: [self isValidWhiteCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame]!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessbord on: aChessGame

	^(self isValidCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessbord on: aChessGame) or: [super isValidMoveFromCoordinate: originCoordinate to: targetCoordinate]!

isValidWhiteCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame

	((originCoordinate ~= #e1) or: [(targetCoordinate ~= #g1) and:[targetCoordinate ~= #c1]]) ifTrue: [^false].

	(targetCoordinate = #g1) ifTrue: [aChessGame ifWhiteKindSideCastleNotEnabled: [^false]].

	(targetCoordinate = #c1) ifTrue: [aChessGame ifWhiteQueenSideCastleNotEnabled: [^false]].

	aChessboard oppositeSideOfSideNamed: (aChessGame nextSideToMoveOn: aChessboard) do: [:side | 
		side allAttackedSquaresDo: [:square |  | castleSquareCollection |
			castleSquareCollection := (targetCoordinate = #g1)
				ifTrue: [#(#e1 #f1 #g1)]
				ifFalse: [#(#e1#d1 #c1 #b1)].
			(castleSquareCollection includes: square coordinate) ifTrue: [^false].
		].
	].
	^true
	!

orientations

	^OrderedCollection new
		add: ChessOrientationVector newNorth;
		add: ChessOrientationVector newSouth;
		add: ChessOrientationVector newWest;
		add: ChessOrientationVector newEast;
		add: ChessOrientationVector newNorthWest;
		add: ChessOrientationVector newNorthEast;
		add: ChessOrientationVector newSouthWest;
		add: ChessOrientationVector newSouthEast;
		yourself!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		aChessSquare kingSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary! !
!King categoriesForMethods!
isValidBlackCastleMoveFrom:to:on:on:!public! !
isValidCastleMoveFrom:to:on:on:!public! !
isValidMoveFromCoordinate:to:on:on:!public! !
isValidWhiteCastleMoveFrom:to:on:on:!public! !
orientations!public! !
squaresScopeFrom:!new framework!public! !
!

!Knight methodsFor!

orientations

	^OrderedCollection 
		with: ChessOrientationVector newNorthWest 
		with: ChessOrientationVector newNorthEast
		with: ChessOrientationVector newSouthWest
		with: ChessOrientationVector newSouthEast!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		aChessSquare knightSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary! !
!Knight categoriesForMethods!
orientations!new framework!orientations do!public! !
squaresScopeFrom:!new framework!public! !
!

!Pawn methodsFor!

isValidBlackEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame 

	self oppositeSideDo: [:side | (side anyPawnAtEnPassantMoveFrom: originCoordinate) ifFalse: [^false]].

	^aChessGame lastMoveIsBlackEnPassantEnablerFrom: originCoordinate to: targetCoordinate
	!

isValidEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame

	^self isBlack 
	ifTrue: [self isValidBlackEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame] 
	ifFalse: [self isValidWhiteEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame]!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGame

	^(super isValidMoveFromCoordinate: originCoordinate to: targetCoordinate) or: [self isValidEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame]!

isValidWhiteEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame 

	self oppositeSideDo: [:side | (side anyPawnAtEnPassantMoveFrom: originCoordinate) ifFalse: [^false]].

	^aChessGame lastMoveIsWhiteEnPassantEnablerFrom: originCoordinate to: targetCoordinate
	!

orientations

	^self isWhite
	ifTrue: [OrderedCollection new
			add: ChessOrientationVector newNorth;
			add: ChessOrientationVector newNorthWest;
			add: ChessOrientationVector newNorthEast;
			yourself]
	ifFalse: [OrderedCollection new
			add: ChessOrientationVector newSouth;
			add: ChessOrientationVector newSouthWest;
			add: ChessOrientationVector newSouthEast;
			yourself]!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		self isWhite 
		ifTrue: [aChessSquare whitePawnSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare]] 
		ifFalse: [aChessSquare blackPawnSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare]].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary
	! !
!Pawn categoriesForMethods!
isValidBlackEnPassantMoveFrom:to:on:!public! !
isValidEnPassantMoveFrom:to:on:!public! !
isValidMoveFromCoordinate:to:on:!public! !
isValidWhiteEnPassantMoveFrom:to:on:!public! !
orientations!new framework!public! !
squaresScopeFrom:!new framework!public! !
!

!Queen methodsFor!

orientations

	^OrderedCollection new
		add: ChessOrientationVector newNorth;
		add: ChessOrientationVector newSouth;
		add: ChessOrientationVector newWest;
		add: ChessOrientationVector newEast;
		add: ChessOrientationVector newNorthWest;
		add: ChessOrientationVector newNorthEast;
		add: ChessOrientationVector newSouthWest;
		add: ChessOrientationVector newSouthEast;
		yourself! !
!Queen categoriesForMethods!
orientations!new framework!public! !
!

!Rook methodsFor!

orientations

	^OrderedCollection 
		with: ChessOrientationVector newNorth
		with: ChessOrientationVector newSouth
		with: ChessOrientationVector newWest
		with: ChessOrientationVector newEast! !
!Rook categoriesForMethods!
orientations!new framework!public! !
!

!SlidingPiece methodsFor!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		aChessSquare slidingSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary! !
!SlidingPiece categoriesForMethods!
squaresScopeFrom:!new framework!public! !
!

"End of package definition"!

