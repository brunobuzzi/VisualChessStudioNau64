| package |
package := Package name: 'ChessBasicElements'.
package paxVersion: 1;
	basicComment: 'Todo List:

* Unify ChessGamePgnInterpreter and ChessPgnParser both implement the same protocol #buildGameFor:, etc
   - Also share instances variables (the original idea was to implement this behavior on ChessGamePgnInterpreter)

* More tests for complicated positions.

* Start to think on the ChessEngine and similars

* Implement Tactical searchers



Info 01 (HGMuller):
"Well, I am an engine programmer, and engines are basically very stupid, but very, very fast. They just generate possible sequece of moves of a certain length (the ''search depth''), and at the end (if there is no checkmate, which usually there isn''t) use a very simple method to ''evaluate'' the resulting position as a number indicating how desirable it is for one side or the other. This evaluation usually contains material (addition of piece values, P=1, N,B=3, R=5...), and as a much smaller term centralization (for pieces that benefit from it, assigning points to each board square), actual mobility (i.e. number of moves, taking account of blocking by other pieces), Pawn structure bonuses (advance, passers, isolated, doubled and backward Pawns) and King safety (presence of a Pawn shield, number of squares from which the King can be ''seen'', number of squares next to the King actually attacked by enemy pieces).

That is basically all. The evaluation usually fails badly in non-quiet positions (i.e. when one side is a Queen ''ahead'', but it is not his move and the Queen is attacked and not protected), and to solve that engines always consider grabbing material at the end of a line, even if it is beyond the intended depth (''quiescence search''). So they just trade until no captures are possible anymore, and evaluate then. If no captures gain material (or other advantages), the position is by definition quiet, and they trust the evaluation for it.

Then they simply make the move that forces the best outcome for them (evaluation-wise), assuming what they consider optimal defense. Modern engines do not search all possible lines to the same depth, but ''reduce'' branches they think are not promising (e.g. because they lose material early on), meaning they subtract some number of half-moves from the nominal search depth, until it is proven that the loss can be recouped (i.e. was a sound sacrifice rather than a blunder), at which time that branch gains back the full nominal depth.

That is basically it. With current computer speeds millions of positions can be searched per second, and a simple program of about 100 lines of computer code, not having much more than material and centralization/pawn advance in its evaluation (like Fairy-Max) can already be a very tough opponent for a good club player.
"'.

package basicScriptAt: #postinstall put: 'ChessFile initializeFiles.
ChessRank initializeRanks.
ChessSquare initializeAllSquares.'.

package classNames
	add: #Bishop;
	add: #Chessboard;
	add: #ChessCoordinate;
	add: #ChessFile;
	add: #ChessPiece;
	add: #ChessRank;
	add: #ChessSide;
	add: #ChessSideBlack;
	add: #ChessSideWhite;
	add: #ChessSquare;
	add: #King;
	add: #Knight;
	add: #Nau64ChessSystemRoot;
	add: #Nau64UserPreferences;
	add: #Pawn;
	add: #Queen;
	add: #Rook;
	add: #SlidingPiece;
	yourself.

package methodNames
	add: #OrderedCollection -> #ifAbsentAdd:;
	add: #SmallInteger -> #isInChessRange;
	add: #Symbol -> #asChessSquareIn:;
	yourself.

package globalNames
	add: #AllChessFiles;
	add: #AllChessRanks;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base'
	'..\Core\Object Arts\Dolphin\MVP\Icons\Dolphin Text Tile Icons').

package!

"Class Definitions"!

Object subclass: #Chessboard
	instanceVariableNames: 'systemRoot orientation squareSize blackSide whiteSide pieces'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessCoordinate
	instanceVariableNames: 'systemRoot name'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessPiece
	instanceVariableNames: 'chessSide'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessSide
	instanceVariableNames: 'chessboard'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessSquare
	instanceVariableNames: 'systemRoot file rank'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #Nau64ChessSystemRoot
	instanceVariableNames: 'files ranks squares userPreferences'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #Nau64UserPreferences
	instanceVariableNames: 'unicodeFontNameForPieces squareWhiteColor squareBlackColor'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessCoordinate subclass: #ChessFile
	instanceVariableNames: ''
	classVariableNames: 'AllChessFiles'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessCoordinate subclass: #ChessRank
	instanceVariableNames: ''
	classVariableNames: 'AllChessRanks'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessPiece subclass: #King
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessPiece subclass: #Knight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessPiece subclass: #Pawn
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessPiece subclass: #SlidingPiece
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SlidingPiece subclass: #Bishop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SlidingPiece subclass: #Queen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SlidingPiece subclass: #Rook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessSide subclass: #ChessSideBlack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessSide subclass: #ChessSideWhite
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!OrderedCollection methodsFor!

ifAbsentAdd: anObject

	^(self includes: anObject)
	ifTrue: [anObject] 
	ifFalse: [self add: anObject]! !
!OrderedCollection categoriesForMethods!
ifAbsentAdd:!public! !
!

!SmallInteger methodsFor!

isInChessRange
	^self >= 1 and: [self <= 8]! !
!SmallInteger categoriesForMethods!
isInChessRange!public! !
!

!Symbol methodsFor!

asChessSquareIn: aSystemRoot

	self size = 2 ifFalse: [self error: 'Wrong size, it must be 2'].

	^aSystemRoot squareAt: (self first asString , self second asString) asSymbol
! !
!Symbol categoriesForMethods!
asChessSquareIn:!public! !
!

"End of package definition"!

