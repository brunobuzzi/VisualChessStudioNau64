| package |
package := Package name: 'ChessPiecesMovementsEngine'.
package paxVersion: 1;
	basicComment: ''.


package classNames
	add: #ChessEastOrientation;
	add: #ChessEngineOrientationTreeNode;
	add: #ChessEngineSquareTreeNode;
	add: #ChessEngineTreeNode;
	add: #ChessNorthOrientation;
	add: #ChessOrientation;
	add: #ChessOrientationVector;
	add: #ChessPieceDictionary;
	add: #ChessSouthOrientation;
	add: #ChessVector;
	add: #ChessWestOrientation;
	add: #OrientationDictionary;
	add: #SquaresDictionary;
	yourself.

package methodNames
	add: #Bishop -> #orientations;
	add: #ChessPiece -> #checkNoAbsolutePinFrom:to:;
	add: #ChessPiece -> #currentChessSquare;
	add: #ChessPiece -> #isInvalidMoveFrom:to:;
	add: #ChessPiece -> #isValidMoveFrom:to:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:on:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:on:on:;
	add: #ChessPiece -> #orientations;
	add: #ChessPiece -> #orientationVectorFrom:to:;
	add: #ChessPiece -> #printCurrentSquareOn:;
	add: #King -> #isValidBlackCastleMoveFrom:to:on:on:;
	add: #King -> #isValidCastleMoveFrom:to:on:on:;
	add: #King -> #isValidMoveFromCoordinate:to:on:on:;
	add: #King -> #isValidWhiteCastleMoveFrom:to:on:on:;
	add: #King -> #orientations;
	add: #King -> #squaresScopeFrom:;
	add: #Knight -> #orientations;
	add: #Knight -> #squaresScopeFrom:;
	add: #Pawn -> #isValidBlackEnPassantMoveFrom:to:on:;
	add: #Pawn -> #isValidEnPassantMoveFrom:to:on:;
	add: #Pawn -> #isValidMoveFromCoordinate:to:on:;
	add: #Pawn -> #isValidWhiteEnPassantMoveFrom:to:on:;
	add: #Pawn -> #orientations;
	add: #Pawn -> #squaresScopeFrom:;
	add: #Queen -> #orientations;
	add: #Rook -> #orientations;
	add: #SlidingPiece -> #squaresScopeFrom:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'ChessBasicElements'
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base'
	'..\Core\Object Arts\Dolphin\MVP\Icons\Dolphin Text Tile Icons').

package!

"Class Definitions"!

Object subclass: #ChessEngineTreeNode
	instanceVariableNames: 'tree parentNode children'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessPieceDictionary
	instanceVariableNames: 'piece'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessVector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessEngineTreeNode subclass: #ChessEngineOrientationTreeNode
	instanceVariableNames: 'orientation'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessEngineTreeNode subclass: #ChessEngineSquareTreeNode
	instanceVariableNames: 'square movementEngine'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessEastOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessNorthOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessSouthOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessWestOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessPieceDictionary subclass: #OrientationDictionary
	instanceVariableNames: 'orientations'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessPieceDictionary subclass: #SquaresDictionary
	instanceVariableNames: 'squares'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessVector subclass: #ChessOrientationVector
	instanceVariableNames: 'southOrNorth eastOrWest'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!Bishop methodsFor!

orientations

	^OrderedCollection 
		with: ChessOrientationVector newNorthWest 
		with: ChessOrientationVector newNorthEast
		with: ChessOrientationVector newSouthWest
		with: ChessOrientationVector newSouthEast! !
!Bishop categoriesForMethods!
orientations!new framework!orientations do!public! !
!

!ChessPiece methodsFor!

checkNoAbsolutePinFrom: originChessSquare to: targetChessSquare
	| pins vector |
	pins := OrderedCollection new.
	self oppositeSideDo: [:oppositeSide | 
		oppositeSide piecesDo: [:piece | 
			piece pinnedPieces collectionAndOrientationDo: [:collection :orientation | 
				collection size = 1
				ifTrue: [pins addAll: (collection select: [:pin | (pin pinnedPieceIs: self) and: [pin isAbsolute]])]
			].
		]
	].
	pins isEmpty ifTrue: [^true].

	vector := ChessOrientationVector newFrom:  originChessSquare to: targetChessSquare.

	^pins allSatisfy: [:pin | vector isPinCompatibleWithOrientationNamed: pin orientation]!

currentChessSquare

	^chessSide currentChessSquareFor: self!

isInvalidMoveFrom: originChessSquare to: targetChessSquare

	^(self isValidMoveFrom: originChessSquare to: targetChessSquare) not

	!

isValidMoveFrom: originChessSquare to: targetChessSquare
	| isValid |

	isValid := false.
	self squaresToMoveFrom: originChessSquare do: [:scopeSquare | scopeSquare == targetChessSquare ifTrue: [isValid := true]].

	isValid := isValid 
			and: [(self checkNoAbsolutePinFrom: originChessSquare to: targetChessSquare) 
				and: [(chessSide isStillInCheckAfterMoveFrom: originChessSquare to: targetChessSquare) not]].

	^isValid

	!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate

	^self isValidMoveFrom: (originCoordinate asChessSquareIn: self systemRoot) to: (targetCoordinate asChessSquareIn: self systemRoot)!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGameExecutor

	^self isValidMoveFrom: (originCoordinate asChessSquareIn: self systemRoot) to: (targetCoordinate asChessSquareIn: self systemRoot)!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessbord on: aChessGameExecutor

	^self isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGameExecutor!

orientations

	^OrderedCollection new!

orientationVectorFrom: sourceChessSquare to: targetChessSquare

	^ChessOrientationVector newFrom: sourceChessSquare to: targetChessSquare.!

printCurrentSquareOn: aStream
	| currentSquare |
	currentSquare := self currentChessSquare.
	aStream nextPutAll: currentSquare printName! !
!ChessPiece categoriesForMethods!
checkNoAbsolutePinFrom:to:!new framework!public! !
currentChessSquare!public! !
isInvalidMoveFrom:to:!new framework!public! !
isValidMoveFrom:to:!new framework!public! !
isValidMoveFromCoordinate:to:!public! !
isValidMoveFromCoordinate:to:on:!public! !
isValidMoveFromCoordinate:to:on:on:!public! !
orientations!new framework!public! !
orientationVectorFrom:to:!public! !
printCurrentSquareOn:!public! !
!

!King methodsFor!

isValidBlackCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGameExecutor

	((originCoordinate ~= #e8) or: [(targetCoordinate ~= #g8) and:[targetCoordinate ~= #c8]]) ifTrue: [^false].

	(targetCoordinate = #g8) ifTrue: [aChessGameExecutor ifBlackKindSideCastleNotEnabled: [^false]].

	(targetCoordinate = #c8) ifTrue: [aChessGameExecutor ifBlackQueenSideCastleNotEnabled: [^false]].

	self oppositeSideDo: [:side | 
		side allAttackedSquaresDo: [:square |  | castleSquareCollection |
			castleSquareCollection := (targetCoordinate = #g8)
				ifTrue: [#(#e8 #f8 #g8)]
				ifFalse: [#(#e8#d8 #c8 #b8)].
			(castleSquareCollection includes: square coordinate) ifTrue: [^false].
		].
	].
	^true
	!

isValidCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGameExecutor

	^self isBlack 
	ifTrue: [self isValidBlackCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGameExecutor] 
	ifFalse: [self isValidWhiteCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGameExecutor]!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessbord on: aChessGameExecutor

	^(self isValidCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessbord on: aChessGameExecutor) 
		or: [super isValidMoveFromCoordinate: originCoordinate to: targetCoordinate]!

isValidWhiteCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGameExecutor

	((originCoordinate ~= #e1) or: [(targetCoordinate ~= #g1) and:[targetCoordinate ~= #c1]]) ifTrue: [^false].

	(targetCoordinate = #g1) ifTrue: [aChessGameExecutor ifWhiteKindSideCastleNotEnabled: [^false]].

	(targetCoordinate = #c1) ifTrue: [aChessGameExecutor ifWhiteQueenSideCastleNotEnabled: [^false]].

	self oppositeSideDo: [:side | 
		side allAttackedSquaresDo: [:square |  | castleSquareCollection |
			castleSquareCollection := (targetCoordinate = #g1)
				ifTrue: [#(#e1 #f1 #g1)]
				ifFalse: [#(#e1#d1 #c1 #b1)].
			(castleSquareCollection includes: square coordinate) ifTrue: [^false].
		].
	].
	^true
	!

orientations

	^OrderedCollection new
		add: ChessOrientationVector newNorth;
		add: ChessOrientationVector newSouth;
		add: ChessOrientationVector newWest;
		add: ChessOrientationVector newEast;
		add: ChessOrientationVector newNorthWest;
		add: ChessOrientationVector newNorthEast;
		add: ChessOrientationVector newSouthWest;
		add: ChessOrientationVector newSouthEast;
		yourself!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		aChessSquare kingSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary! !
!King categoriesForMethods!
isValidBlackCastleMoveFrom:to:on:on:!new framework!public! !
isValidCastleMoveFrom:to:on:on:!new framework!public! !
isValidMoveFromCoordinate:to:on:on:!new framework!public! !
isValidWhiteCastleMoveFrom:to:on:on:!new framework!public! !
orientations!public! !
squaresScopeFrom:!new framework!public! !
!

!Knight methodsFor!

orientations

	^OrderedCollection 
		with: ChessOrientationVector newNorthWest 
		with: ChessOrientationVector newNorthEast
		with: ChessOrientationVector newSouthWest
		with: ChessOrientationVector newSouthEast!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		aChessSquare knightSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary! !
!Knight categoriesForMethods!
orientations!new framework!orientations do!public! !
squaresScopeFrom:!new framework!public! !
!

!Pawn methodsFor!

isValidBlackEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGameExecutor 

	self oppositeSideDo: [:side | (side anyPawnAtEnPassantMoveFrom: originCoordinate) ifFalse: [^false]].

	^aChessGameExecutor lastMoveIsBlackEnPassantEnabledFrom: originCoordinate to: targetCoordinate
	!

isValidEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGameExecutor

	^self isBlack 
	ifTrue: [self isValidBlackEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGameExecutor] 
	ifFalse: [self isValidWhiteEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGameExecutor]!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGameExecutor

	^(super isValidMoveFromCoordinate: originCoordinate to: targetCoordinate) 
		or: [self isValidEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGameExecutor]!

isValidWhiteEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGameExecutor 

	self oppositeSideDo: [:side | (side anyPawnAtEnPassantMoveFrom: originCoordinate) ifFalse: [^false]].

	^aChessGameExecutor lastMoveIsWhiteEnPassantEnabledFrom: originCoordinate to: targetCoordinate
	!

orientations

	^self isWhite
	ifTrue: [OrderedCollection new
			add: ChessOrientationVector newNorth;
			add: ChessOrientationVector newNorthWest;
			add: ChessOrientationVector newNorthEast;
			yourself]
	ifFalse: [OrderedCollection new
			add: ChessOrientationVector newSouth;
			add: ChessOrientationVector newSouthWest;
			add: ChessOrientationVector newSouthEast;
			yourself]!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		self isWhite 
		ifTrue: [aChessSquare whitePawnSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare]] 
		ifFalse: [aChessSquare blackPawnSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare]].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary
	! !
!Pawn categoriesForMethods!
isValidBlackEnPassantMoveFrom:to:on:!public! !
isValidEnPassantMoveFrom:to:on:!public! !
isValidMoveFromCoordinate:to:on:!public! !
isValidWhiteEnPassantMoveFrom:to:on:!public! !
orientations!new framework!public! !
squaresScopeFrom:!new framework!public! !
!

!Queen methodsFor!

orientations

	^OrderedCollection new
		add: ChessOrientationVector newNorth;
		add: ChessOrientationVector newSouth;
		add: ChessOrientationVector newWest;
		add: ChessOrientationVector newEast;
		add: ChessOrientationVector newNorthWest;
		add: ChessOrientationVector newNorthEast;
		add: ChessOrientationVector newSouthWest;
		add: ChessOrientationVector newSouthEast;
		yourself! !
!Queen categoriesForMethods!
orientations!new framework!public! !
!

!Rook methodsFor!

orientations

	^OrderedCollection 
		with: ChessOrientationVector newNorth
		with: ChessOrientationVector newSouth
		with: ChessOrientationVector newWest
		with: ChessOrientationVector newEast! !
!Rook categoriesForMethods!
orientations!new framework!public! !
!

!SlidingPiece methodsFor!

squaresScopeFrom: aChessSquare
	| scopeDictionary |

	scopeDictionary := SquaresDictionary on: self.

	self orientationsDo: [:chessOrientationVector | | scopeCollection |
		scopeCollection := OrderedCollection new.
		aChessSquare slidingSquaresWith: chessOrientationVector do: [:eachSquare | scopeCollection add: eachSquare].
		scopeDictionary atOrientation: chessOrientationVector vectorName put: scopeCollection.
	].

	^scopeDictionary! !
!SlidingPiece categoriesForMethods!
squaresScopeFrom:!new framework!public! !
!

"End of package definition"!

