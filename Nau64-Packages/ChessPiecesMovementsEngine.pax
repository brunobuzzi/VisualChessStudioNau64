| package |
package := Package name: 'ChessPiecesMovementsEngine'.
package paxVersion: 1;
	basicComment: ''.


package classNames
	add: #BishopMovementEngine;
	add: #ChessEastOrientation;
	add: #ChessEngineOrientationTreeNode;
	add: #ChessEnginePieceStackTree;
	add: #ChessEngineSquareTreeNode;
	add: #ChessEngineTreeNode;
	add: #ChessMovementEngine;
	add: #ChessNorthOrientation;
	add: #ChessOrientation;
	add: #ChessOrientationVector;
	add: #ChessSouthOrientation;
	add: #ChessWestOrientation;
	add: #KingMovementEngine;
	add: #KnightMovementEngine;
	add: #PawnMovementEngine;
	add: #QueenMovementEngine;
	add: #RookMovementEngine;
	add: #SlidingPieceMovementEngine;
	add: #SquaresDictionary;
	yourself.

package methodNames
	add: #Bishop -> #defaultMovementRuleClass;
	add: #ChessPiece -> #currentChessSquare;
	add: #ChessPiece -> #defaultMovementRuleClass;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:on:;
	add: #ChessPiece -> #isValidMoveFromCoordinate:to:on:on:;
	add: #ChessPiece -> #newMovementEngine;
	add: #ChessPiece -> #newMovementEngineOn:;
	add: #King -> #defaultMovementRuleClass;
	add: #King -> #isValidBlackCastleMoveFrom:to:on:on:;
	add: #King -> #isValidCastleMoveFrom:to:on:on:;
	add: #King -> #isValidMoveFromCoordinate:to:on:on:;
	add: #King -> #isValidWhiteCastleMoveFrom:to:on:on:;
	add: #Knight -> #defaultMovementRuleClass;
	add: #Pawn -> #defaultMovementRuleClass;
	add: #Pawn -> #isValidBlackEnPassantMoveFrom:to:on:;
	add: #Pawn -> #isValidEnPassantMoveFrom:to:on:;
	add: #Pawn -> #isValidMoveFromCoordinate:to:on:;
	add: #Pawn -> #isValidWhiteEnPassantMoveFrom:to:on:;
	add: #Queen -> #defaultMovementRuleClass;
	add: #Rook -> #defaultMovementRuleClass;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'ChessBasicElements'
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base'
	'..\Core\Object Arts\Dolphin\MVP\Models\Tree\Dolphin Tree Models').

package!

"Class Definitions"!

Object subclass: #ChessEnginePieceStackTree
	instanceVariableNames: 'piece originSquare chessboard roots'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessEngineTreeNode
	instanceVariableNames: 'tree parentNode children'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessMovementEngine
	instanceVariableNames: 'tree piece squaresDictionary'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #ChessOrientationVector
	instanceVariableNames: 'piece southOrNorth eastOrWest'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #SquaresDictionary
	instanceVariableNames: 'squares piece'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessEngineTreeNode subclass: #ChessEngineOrientationTreeNode
	instanceVariableNames: 'orientation'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessEngineTreeNode subclass: #ChessEngineSquareTreeNode
	instanceVariableNames: 'square movementEngine'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessMovementEngine subclass: #KingMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessMovementEngine subclass: #KnightMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessMovementEngine subclass: #PawnMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessMovementEngine subclass: #SlidingPieceMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SlidingPieceMovementEngine subclass: #BishopMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SlidingPieceMovementEngine subclass: #QueenMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SlidingPieceMovementEngine subclass: #RookMovementEngine
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessEastOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessNorthOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessSouthOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ChessOrientation subclass: #ChessWestOrientation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!Bishop methodsFor!

defaultMovementRuleClass
	^BishopMovementEngine! !
!Bishop categoriesForMethods!
defaultMovementRuleClass!public! !
!

!ChessPiece methodsFor!

currentChessSquare

	^chessSide currentChessSquareFor: self!

defaultMovementRuleClass

	self subclassResponsibility
!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate
	| rule isValid |

	rule := self defaultMovementRuleClass newFor: self.

	chessSide chessboardDo: [:chessboard | 
		isValid := rule isValidOn: chessboard from: (originCoordinate asChessSquareIn: self systemRoot) to: (targetCoordinate asChessSquareIn: self systemRoot)].

	^isValid
!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGame

	^self isValidMoveFromCoordinate: originCoordinate to: targetCoordinate!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessbord on: aChessGame

	^self isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGame!

newMovementEngine
	^self defaultMovementRuleClass newFor: self!

newMovementEngineOn: aChessMovementEngineStackTree

	^self defaultMovementRuleClass newFor: self tree: aChessMovementEngineStackTree! !
!ChessPiece categoriesForMethods!
currentChessSquare!public! !
defaultMovementRuleClass!public! !
isValidMoveFromCoordinate:to:!public! !
isValidMoveFromCoordinate:to:on:!public! !
isValidMoveFromCoordinate:to:on:on:!public! !
newMovementEngine!public! !
newMovementEngineOn:!public! !
!

!King methodsFor!

defaultMovementRuleClass
	^KingMovementEngine!

isValidBlackCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame

	((originCoordinate ~= #e8) or: [(targetCoordinate ~= #g8) and:[targetCoordinate ~= #c8]]) ifTrue: [^false].

	(targetCoordinate = #g8) ifTrue: [aChessGame ifBlackKindSideCastleNotEnabled: [^false]].

	(targetCoordinate = #c8) ifTrue: [aChessGame ifBlackQueenSideCastleNotEnabled: [^false]].

	aChessboard oppositeSideOfSideNamed: (aChessGame nextSideToMoveOn: aChessboard) do: [:side | 
		side allAttackedSquaresDo: [:square |  | castleSquareCollection |
			castleSquareCollection := (targetCoordinate = #g1)
				ifTrue: [#(#e8 #f8 #g8)]
				ifFalse: [#(#e8#d8 #c8 #b8)].
			(castleSquareCollection includes: square coordinate) ifTrue: [^false].
		].
	].
	^true
	!

isValidCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame

	^self isBlack 
	ifTrue: [self isValidBlackCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame] 
	ifFalse: [self isValidWhiteCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame]!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessbord on: aChessGame

	^(self isValidCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessbord on: aChessGame) or: [super isValidMoveFromCoordinate: originCoordinate to: targetCoordinate]!

isValidWhiteCastleMoveFrom: originCoordinate to: targetCoordinate on: aChessboard on: aChessGame

	((originCoordinate ~= #e1) or: [(targetCoordinate ~= #g1) and:[targetCoordinate ~= #c1]]) ifTrue: [^false].

	(targetCoordinate = #g1) ifTrue: [aChessGame ifWhiteKindSideCastleNotEnabled: [^false]].

	(targetCoordinate = #c1) ifTrue: [aChessGame ifWhiteQueenSideCastleNotEnabled: [^false]].

	aChessboard oppositeSideOfSideNamed: (aChessGame nextSideToMoveOn: aChessboard) do: [:side | 
		side allAttackedSquaresDo: [:square |  | castleSquareCollection |
			castleSquareCollection := (targetCoordinate = #g1)
				ifTrue: [#(#e1 #f1 #g1)]
				ifFalse: [#(#e1#d1 #c1 #b1)].
			(castleSquareCollection includes: square coordinate) ifTrue: [^false].
		].
	].
	^true
	! !
!King categoriesForMethods!
defaultMovementRuleClass!public! !
isValidBlackCastleMoveFrom:to:on:on:!public! !
isValidCastleMoveFrom:to:on:on:!public! !
isValidMoveFromCoordinate:to:on:on:!public! !
isValidWhiteCastleMoveFrom:to:on:on:!public! !
!

!Knight methodsFor!

defaultMovementRuleClass
	^KnightMovementEngine! !
!Knight categoriesForMethods!
defaultMovementRuleClass!public! !
!

!Pawn methodsFor!

defaultMovementRuleClass
	^PawnMovementEngine!

isValidBlackEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame 

	self oppositeSideDo: [:side | (side anyPawnAtEnPassantMoveFrom: originCoordinate) ifFalse: [^false]].

	^aChessGame lastMoveIsBlackEnPassantEnablerFrom: originCoordinate to: targetCoordinate
	!

isValidEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame

	^self isBlack 
	ifTrue: [self isValidBlackEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame] 
	ifFalse: [self isValidWhiteEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame]!

isValidMoveFromCoordinate: originCoordinate to: targetCoordinate on: aChessGame

	^(super isValidMoveFromCoordinate: originCoordinate to: targetCoordinate) or: [self isValidEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame]!

isValidWhiteEnPassantMoveFrom: originCoordinate to: targetCoordinate on: aChessGame 

	self oppositeSideDo: [:side | (side anyPawnAtEnPassantMoveFrom: originCoordinate) ifFalse: [^false]].

	^aChessGame lastMoveIsWhiteEnPassantEnablerFrom: originCoordinate to: targetCoordinate
	! !
!Pawn categoriesForMethods!
defaultMovementRuleClass!public! !
isValidBlackEnPassantMoveFrom:to:on:!public! !
isValidEnPassantMoveFrom:to:on:!public! !
isValidMoveFromCoordinate:to:on:!public! !
isValidWhiteEnPassantMoveFrom:to:on:!public! !
!

!Queen methodsFor!

defaultMovementRuleClass
	^QueenMovementEngine! !
!Queen categoriesForMethods!
defaultMovementRuleClass!public! !
!

!Rook methodsFor!

defaultMovementRuleClass
	^RookMovementEngine! !
!Rook categoriesForMethods!
defaultMovementRuleClass!public! !
!

"End of package definition"!

